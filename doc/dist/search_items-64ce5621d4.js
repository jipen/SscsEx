searchNodes=[{"ref":"SscsEx.html","title":"SscsEx","type":"module","doc":"SscsEx: A Simple Sftp Client/Server written in Elixir. See https://hexdocs.pm/elixir/Application.html for more information on OTP Applications"},{"ref":"SscsEx.html#clean_failed_transfers/0","title":"SscsEx.clean_failed_transfers/0","type":"function","doc":"Remove all failed transfers from the list: Inputs: None. Outputs: &quot;Failed transfers table cleaned up.&quot;"},{"ref":"SscsEx.html#display_failed_transfers/0","title":"SscsEx.display_failed_transfers/0","type":"function","doc":"Display the list of failed transfers: Inputs: None. Outputs: List of transfers"},{"ref":"SscsEx.html#get_conf/0","title":"SscsEx.get_conf/0","type":"function","doc":"Display the configuration of the SSCS server (system variables SSCS_* values): Inputs: None. Outputs: List of SSCS_* values"},{"ref":"SscsEx.html#get_file/4","title":"SscsEx.get_file/4","type":"function","doc":"Download of a remote file. Inputs: local_path: path of the local file, remote_path: path of the remote file, host: host name of remote server, port: port number of listening remote server Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.html#get_file_append/4","title":"SscsEx.get_file_append/4","type":"function","doc":"Resume the download of a remote file. Inputs: local_path: path of the local file, remote_path: path of the remote file, host: host name of remote server, port: port number of listening remote server Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.html#ping/2","title":"SscsEx.ping/2","type":"function","doc":"Ping a remote server: Inputs: host: name of remote host, port: port of remote host. Outputs: {:ok, &quot;SSH Host host, port is reachable&quot;} | {:error, &quot;SSH Host host, port is unreachable&quot; }"},{"ref":"SscsEx.html#send_file/4","title":"SscsEx.send_file/4","type":"function","doc":"Upload of a local file. Inputs: local_path: path of the local file, remote_path: path of the remote file, host: host name of remote server, port: port number of listening remote server Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.html#send_file_append/4","title":"SscsEx.send_file_append/4","type":"function","doc":"Resume the upload of a local file. Inputs: local_path: path of the local file, remote_path: path of the remote file, host: host name of remote server, port: port number of listening remote server Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.html#start/0","title":"SscsEx.start/0","type":"function","doc":""},{"ref":"SscsEx.html#start/2","title":"SscsEx.start/2","type":"function","doc":"Called when an application is started. This function is called when an application is started using Application.start/2 (and functions on top of that, such as Application.ensure_started/2). This function should start the top-level process of the application (which should be the top supervisor of the application&#39;s supervision tree if the application follows the OTP design principles around supervision). start_type defines how the application is started: :normal - used if the startup is a normal startup or if the application is distributed and is started on the current node because of a failover from another node and the application specification key :start_phases is :undefined. {:takeover, node} - used if the application is distributed and is started on the current node because of a failover on the node node. {:failover, node} - used if the application is distributed and is started on the current node because of a failover on node node, and the application specification key :start_phases is not :undefined. start_args are the arguments passed to the application in the :mod specification key (e.g., mod: {MyApp, [:my_args]}). This function should either return {:ok, pid} or {:ok, pid, state} if startup is successful. pid should be the PID of the top supervisor. state can be an arbitrary term, and if omitted will default to []; if the application is later stopped, state is passed to the stop/1 callback (see the documentation for the c:stop/1 callback for more information). use Application provides no default implementation for the start/2 callback. Callback implementation for Application.start/2."},{"ref":"SscsEx.html#stop/0","title":"SscsEx.stop/0","type":"function","doc":"&quot;Gracefully&quot; stops the SSCS server (close SSH + save failed transfers on disk): Inputs: None. Outputs: &quot;Gracefully terminating the SSCS server...&quot;"},{"ref":"SscsEx.Append.html","title":"SscsEx.Append","type":"module","doc":""},{"ref":"SscsEx.Append.html#local_file/4","title":"SscsEx.Append.local_file/4","type":"function","doc":"Append the excess part of the local_file to the remote file, accounting their respectives sizes. If the remote file doesn&#39;t exist, it is created and the local file is fully downloaded in it. NB: checksum_type could be: :sha, :sha224, :sha256, :sha384, :sha512, :sha3_224, :sha3_256, :sha3_384, :sha3_512, :blake2b, :blake2s, :md5 or :md4 ## Inputs: connection: SSH connection, local_path: path of the local file, remote_path: path of the remote file, checksum_type: can be :sha, :sha224, :sha256, :sha384, :sha512, :sha3_224, :sha3_256, :sha3_384, :sha3_512, :blake2b, :blake2s, :md5 or :md4 Outputs: {:ok, &quot;Checksum (type: checksum_type) for both files = checksum&quot;} | {:error, &quot;Couldn&#39;t resume uploading local file local_path to remote file remote_path: reason: reason&quot;"},{"ref":"SscsEx.Append.html#local_file_streamed/5","title":"SscsEx.Append.local_file_streamed/5","type":"function","doc":"Append &quot;streamingly&quot; the excess part of a local file to a remote file, accounting their respectives sizes .. If the remote file doesn&#39;t exist, it is created and the local file is fully appended to it (ie uploaded). Inputs: connection: SSH connection, local_path: path of the local file, remote_path: path of the remote file, checksum_type: can be :sha, :sha224, :sha256, :sha384, :sha512, :sha3_224, :sha3_256, :sha3_384, :sha3_512, :blake2b, :blake2s, :md5 or :md4, bytes_size: size of the chunks used in streaming. Outputs: {:ok, &quot;Checksum (type: checksum_type) for both files = checksum&quot;} | {:error, &quot;Bad checksum (type: checksum_type}) : local file checksum = local checksum} , remote file checksum = remote checksum&quot;} | {:error, reason}"},{"ref":"SscsEx.Append.html#remote_file/4","title":"SscsEx.Append.remote_file/4","type":"function","doc":"Append the excess part of the remote_file to the local_file, accounting their respectives sizes.. If the local file doesn&#39;t exist, it is created and the remote file is fully downloaded in it. Inputs: connection: SSH connection, local_path: path of the local file, remote_path: path of the remote file, checksum_type: can be :sha, :sha224, :sha256, :sha384, :sha512, :sha3_224, :sha3_256, :sha3_384, :sha3_512, :blake2b, :blake2s, :md5 or :md4 Outputs: {:ok, &quot;Checksum (type: checksum_type) for both files = checksum&quot;}, {:error, &quot;Couldn&#39;t resume downloading local file local_path from remote file remote_path: reason: reason&quot;"},{"ref":"SscsEx.Append.html#remote_file_streamed/5","title":"SscsEx.Append.remote_file_streamed/5","type":"function","doc":"Append &quot;streamingly&quot; the excess part of the remote_file to the local_file, accounting their respectives sizes .. If the local file doesn&#39;t exist, it is created and the remote file is fully appended to it (ie downloaded). Inputs: connection: SSH connection, local_path: path of the local file, remote_path: path of the remote file, checksum_type: can be :sha, :sha224, :sha256, :sha384, :sha512, :sha3_224, :sha3_256, :sha3_384, :sha3_512, :blake2b, :blake2s, :md5 or :md4, bytes_size: size of the chunks used in streaming. Outputs: {:ok, &quot;Checksum (type: checksum_type) for both files = checksum&quot;} | {:error, &quot;Bad checksum (type: checksum_type}) : local file checksum = local checksum} , remote file checksum = remote checksum&quot;} | {:error, reason}"},{"ref":"SscsEx.Client.html","title":"SscsEx.Client","type":"module","doc":"Functions for the client side of the SscsEx server."},{"ref":"SscsEx.Client.html#connect/1","title":"SscsEx.Client.connect/1","type":"function","doc":"Establish a connection. Input: conn_opts: connection options (Keywords List) Outputs: {:ok, } | {:error, reason}"},{"ref":"SscsEx.Client.html#disconnect/1","title":"SscsEx.Client.disconnect/1","type":"function","doc":"Close a connection. Input: connection: SSH connection (Map) Outputs: {:ok, } | {:error, reason}"},{"ref":"SscsEx.Client.html#get_file/3","title":"SscsEx.Client.get_file/3","type":"function","doc":"Download a remote file. Inputs: conn_opts: connection options (Keywords List), local_file: path of the local file (String), remote_file: path of the remote file (String) Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.Client.html#get_file_append/3","title":"SscsEx.Client.get_file_append/3","type":"function","doc":"Resume the download of a remote file. Inputs: conn_opts: connection options (Keywords List), local_file: path of the local file (String), remote_file: path of the remote file (String). Outputs: {:ok, message} | {:error, reason}."},{"ref":"SscsEx.Client.html#send_file/3","title":"SscsEx.Client.send_file/3","type":"function","doc":"Upload/send a local file. Inputs: conn_opts: connection options (Keywords List), local_file: path of the local file (String), remote_file: path of the remote file (String) Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.Client.html#send_file_append/3","title":"SscsEx.Client.send_file_append/3","type":"function","doc":"Resume the upload of a local file. Inputs: conn_opts: connection options (Keywords List), local_file: path of the local file (String), remote_file: path of the remote file (String) Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.Client.html#test_checksum/4","title":"SscsEx.Client.test_checksum/4","type":"function","doc":"Test if a local file and a remote file have the same checksum. Inputs: connection: the SSH connection, local_path: the path of the local file, remote_path: the path of the remote file, crc_type: Type of checksum choosen (:sha, :sha224, :sha256, :sha384, :sha512, :sha3_224, :sha3_256, :sha3_384, :sha3_512, :blake2b, :blake2s, :md5 or :md4) Outputs: {:ok, , } | {:error, , }"},{"ref":"SscsEx.Client.html#transfer_file/4","title":"SscsEx.Client.transfer_file/4","type":"function","doc":"Transfer a file using the transfer_func. Inputs: conn_opts: connection options (Keywords List), transfer_func: transfer function name (atom), local_file: path of the local file (String), remote_file: path of the remote file (String) Outputs: {:ok, message} | {:error, &quot;The transfer function is unknown...&quot;}"},{"ref":"SscsEx.Files.html","title":"SscsEx.Files","type":"module","doc":"Functions to manage local files."},{"ref":"SscsEx.Files.html#append_part/2","title":"SscsEx.Files.append_part/2","type":"function","doc":"Append data to the end of local file. Inputs: path: path of the file, data: datas to append. Outputs: Returns: {:ok, nil} or {:error, reason}"},{"ref":"SscsEx.Files.html#append_part_from_stream/3","title":"SscsEx.Files.append_part_from_stream/3","type":"function","doc":"Append stream data to the end of local file. Inputs: path: path of the file stream_data: stream of datas to append, bytes-size: size of chunks of data to be streamed Outputs: {:ok, nil} | {:error, reason}"},{"ref":"SscsEx.Files.html#checksum/2","title":"SscsEx.Files.checksum/2","type":"function","doc":"Compute the checksum of a file. Inputs: file_path: path of the file, crc_type: can be :sha, :sha224, :sha256, :sha384, :sha512, :sha3_224, :sha3_256, :sha3_384, :sha3_512, :blake2b, :blake2s, :md5 or :md4 Outputs: {:ok, &lt;checksum} | {:error, &quot;Wrong file path...&quot;}"},{"ref":"SscsEx.Files.html#create/1","title":"SscsEx.Files.create/1","type":"function","doc":"Create an empty file. Inputs: path: path of the file Outputs: {:ok, nil} | {:error, reason}"},{"ref":"SscsEx.Files.html#is_dir/1","title":"SscsEx.Files.is_dir/1","type":"function","doc":"Check if a path is a folder. Inputs: strdir: path of the folder. Outputs: :ok | :error"},{"ref":"SscsEx.Files.html#is_file/1","title":"SscsEx.Files.is_file/1","type":"function","doc":"Check if a file is of the regular type. Inputs: path: path of the file. Outputs: :ok | :error"},{"ref":"SscsEx.Files.html#read_part/3","title":"SscsEx.Files.read_part/3","type":"function","doc":"Read the local file part from position &#39;start&#39; with the length &#39;length&#39;. Inputs: path: path of the file, start: start position to read on, length: size to read Outputs: {:ok, data} | {:error, reason}"},{"ref":"SscsEx.Files.html#read_part_to_stream/3","title":"SscsEx.Files.read_part_to_stream/3","type":"function","doc":"Read the local file part from position &#39;start&#39; and create a stream from it. Inputs: path: path of the file start: start position to read on, bytes-size: size of chunks of data to be streamed Outputs: {:ok, stream} | {:error, reason}"},{"ref":"SscsEx.Files.html#remove/1","title":"SscsEx.Files.remove/1","type":"function","doc":"Remove a file. Inputs: path: path of the file Outputs: {:ok, &quot;Local file path removed&quot;} | or {:error, &quot;Local file path NOT removed. Reason: reason}&quot;}"},{"ref":"SscsEx.Files.html#size/1","title":"SscsEx.Files.size/1","type":"function","doc":"Give the file size of a file. Inputs: strdir: path of the file. Outputs: {:ok, size} | {:error, reason}"},{"ref":"SscsEx.Files.html#size2/1","title":"SscsEx.Files.size2/1","type":"function","doc":"Give the file size of a file or 0 if the file doesn&#39;t exist. Inputs: path: path of the file. Outputs: {:ok, size} | {:error, &quot;path is not a regular file&quot;} | {:error, &quot;Could not get the size of path. Reason: reason&quot;}}"},{"ref":"SscsEx.Files.html#transfer_rate/3","title":"SscsEx.Files.transfer_rate/3","type":"function","doc":"Compute the transfer rate of a file. Inputs: path: path of the file, seconds: transfer duration, unit: file size unit. Can be: :mb (MB) or :kb (KB) Outputs: {:ok, transfer rate} or {:error, message}"},{"ref":"SscsEx.PreTransfer.html","title":"SscsEx.PreTransfer","type":"module","doc":"Check pre-conditions according to the type of the transfer (Upload/Download/Resume upload/Resume download)."},{"ref":"SscsEx.PreTransfer.html#requisites/4","title":"SscsEx.PreTransfer.requisites/4","type":"function","doc":"Checks prerequisites for the transfer. Create connection and test(_connection, _transfer_type, _is_local_file?, _is_remote_file?, _local_path, _remote_path) Inputs: transfer_type (:get, :send, :reget, :resend), conn_opts (SSH connection options), local_path (path of local file) remote_path (path of remote file) Output: {:ok, connection} | {:error, message} | {:error, reason}"},{"ref":"SscsEx.SFTP.html","title":"SscsEx.SFTP","type":"module","doc":"SFTP Functions for the client side of the SscsEx server."},{"ref":"SscsEx.SFTP.html#append_part_file/3","title":"SscsEx.SFTP.append_part_file/3","type":"function","doc":"Append data to the end of remote file. Inputs: connection: SFTP connection), path: path of the file (String), data: data to append. Outputs: {:ok, nil} | {:error, reason}"},{"ref":"SscsEx.SFTP.html#append_part_file_from_stream/4","title":"SscsEx.SFTP.append_part_file_from_stream/4","type":"function","doc":"Append stream data to the end of remote file stream. Inputs: connection: SFTP connection, path: path of the file, stream_data: datas from stream, bytes_size: size of stream chunks. Outputs: {:ok, nil} | {:error, reason}"},{"ref":"SscsEx.SFTP.html#close_file_handle/2","title":"SscsEx.SFTP.close_file_handle/2","type":"function","doc":"Closes an opened remote file. Inputs: Connection: SFTP connection, handle: file handle. Outputs: :ok | {:error, reason}"},{"ref":"SscsEx.SFTP.html#connect/1","title":"SscsEx.SFTP.connect/1","type":"function","doc":"Creates an SFTP channel Inputs: opts: SSH options, Outputs: {:ok, connection}, or {:error, reason}"},{"ref":"SscsEx.SFTP.html#create_file/2","title":"SscsEx.SFTP.create_file/2","type":"function","doc":"Create an empty remote file given a connection and path. ## Inputs: Connection: SFTP connection, path: path of the remote file . Outputs: {:ok, nil} | {:error, reason}"},{"ref":"SscsEx.SFTP.html#disconnect/1","title":"SscsEx.SFTP.disconnect/1","type":"function","doc":"Stops a SFTP channel and closes the SSH connection. Inputs: connection: SFTP connection Output: :ok | {:error, reason}"},{"ref":"SscsEx.SFTP.html#each_binstream/3","title":"SscsEx.SFTP.each_binstream/3","type":"function","doc":"Read a bitstream from a file (handle). Inputs: Connection: SFTP connection, handle: file handle, byte_length: number of bytes to read Outputs: {:halt, handle} | {[data], handle} | {:error, reason}"},{"ref":"SscsEx.SFTP.html#file_checksum/3","title":"SscsEx.SFTP.file_checksum/3","type":"function","doc":"Return the checksum of a remote file. Inputs: connection: SFTP connection), path: path of the file (String), crc_type: checksum type = :sha, :sha224, :sha256, :sha384, :sha512, :sha3_224, :sha3_256, :sha3_384, :sha3_512, :blake2b, :blake2s, :md5 or :md4. Outputs: {:ok, checksum} | {:error, message}"},{"ref":"SscsEx.SFTP.html#file_exists?/2","title":"SscsEx.SFTP.file_exists?/2","type":"function","doc":"Gives the type of a remote file given a channel PID and path. ## Inputs: Connection: SFTP connection, path: path of the file Outputs: (boolean) true | false"},{"ref":"SscsEx.SFTP.html#file_info/2","title":"SscsEx.SFTP.file_info/2","type":"function","doc":"get the file info of a remote file Inputs: Connection: SFTP connection, path: path of the file (String) Outputs: {:ok, File.Stat} | {:error, reason}"},{"ref":"SscsEx.SFTP.html#file_size/2","title":"SscsEx.SFTP.file_size/2","type":"function","doc":"Gives the type of a remote file given a connection and path. ## Inputs: Connection SFTP connection, path: path of the remote file. Outputs: {:ok, type} | {:error, reason}"},{"ref":"SscsEx.SFTP.html#file_size2/2","title":"SscsEx.SFTP.file_size2/2","type":"function","doc":"Return the size of a remote file or 0 if the file doesn&#39;t exist: Inputs: connection: SFTP connection), path: path of the remote file. Outputs: {:ok, size} if the remote file exists and is actually a file, | {:ok, 0} if the remote file doesn&#39;t exist, | {:error, reason} if the remote file is not a file."},{"ref":"SscsEx.SFTP.html#file_type/2","title":"SscsEx.SFTP.file_type/2","type":"function","doc":"Gives the type of a remote file given a channel PID and path. ## Inputs: Connection: SFTP connection, path: path of the remote file. Outputs: {:ok, type} | {:error, reason}"},{"ref":"SscsEx.SFTP.html#is_file/2","title":"SscsEx.SFTP.is_file/2","type":"function","doc":"Test if a remote file is of the regular type. Inputs: Connection: SFTP connection, path: path of the remote file. Outputs: :ok | :error"},{"ref":"SscsEx.SFTP.html#open_file/3","title":"SscsEx.SFTP.open_file/3","type":"function","doc":"Opens a remote file given a connection and path. ## Inputs: connection: SFTP connection, path: path of the remote file, mode: open modes ([:creat, :write, ...]). Outputs: {:ok, handle} | {:error, reason}"},{"ref":"SscsEx.SFTP.html#read_part_file/4","title":"SscsEx.SFTP.read_part_file/4","type":"function","doc":"Read &#39;length&#39; bytes from the remote file part, starting at &#39;start&#39; position. Inputs: connection: SFTP connection), path: path of the file (String), start: start position (integer), length: number of bytes to read (integer) Outputs: {:ok, data} | {:error, reason}"},{"ref":"SscsEx.SFTP.html#read_part_file_to_stream/4","title":"SscsEx.SFTP.read_part_file_to_stream/4","type":"function","doc":"Read the remote file part from position &#39;start&#39; and stream it. Inputs: connection: SFTP connection, path: path of the remote file, start: start position, bytes_size: size of stream chunks. Outputs: {:ok, stream} | {:error, reason}"},{"ref":"SscsEx.SFTP.html#remove_file/2","title":"SscsEx.SFTP.remove_file/2","type":"function","doc":"Remove a remote file. Inputs: Connection: SFTP connection, path: path of the remote file. Outputs: {:ok, message} or {:error, message}"},{"ref":"SscsEx.SFTP.html#stream_create!/3","title":"SscsEx.SFTP.stream_create!/3","type":"function","doc":"Open a stream on a file for create and write ## Inputs: connection: SFTP connection), path: path of the file (String), byte_size: stream chunks size (integer) Outputs: StreamFile or {:error, reason}"},{"ref":"SscsEx.SFTP.html#stream_read!/3","title":"SscsEx.SFTP.stream_read!/3","type":"function","doc":"Open a stream on a file for reading ## Inputs: connection: SFTP connection), path: path of the file (String), byte_size: stream chunks size (integer) Output: StreamFile | {:error, reason}"},{"ref":"SscsEx.SFTP.html#stream_write!/3","title":"SscsEx.SFTP.stream_write!/3","type":"function","doc":"Open a stream on a file to write ## Inputs: connection: SFTP connection), path: path of the file (String), byte_size: stream chunks size (integer) Outputs: StreamFile | {:error, reason}"},{"ref":"SscsEx.SFTP.html#write_handle/3","title":"SscsEx.SFTP.write_handle/3","type":"function","doc":"Writes data to a open file using the channel PID ## Inputs: Connection: SFTP connection, handle: handle of the file, data: data to write Outputs: :ok | :error"},{"ref":"SscsEx.SFTP.html#t:connection_t/0","title":"SscsEx.SFTP.connection_t/0","type":"type","doc":""},{"ref":"SscsEx.SFTP.html#t:crc_t/0","title":"SscsEx.SFTP.crc_t/0","type":"type","doc":""},{"ref":"SscsEx.SFTP.html#t:str_or_charlist_t/0","title":"SscsEx.SFTP.str_or_charlist_t/0","type":"type","doc":""},{"ref":"SscsEx.Server.html","title":"SscsEx.Server","type":"module","doc":"Functions for the server side of the SscsEx server."},{"ref":"SscsEx.Server.html#child_spec/1","title":"SscsEx.Server.child_spec/1","type":"function","doc":"Returns a specification to start this module under a supervisor. See Supervisor."},{"ref":"SscsEx.Server.html#clean_table/0","title":"SscsEx.Server.clean_table/0","type":"function","doc":"Clean up the content of failed transfers table:"},{"ref":"SscsEx.Server.html#display_table/0","title":"SscsEx.Server.display_table/0","type":"function","doc":"Display the content of failed transfers table:"},{"ref":"SscsEx.Server.html#get_file/4","title":"SscsEx.Server.get_file/4","type":"function","doc":"Download of a remote file. Inputs: local_file: path of the local file, remote_file: path of the remote file, host: host name of remote server, port: port number of listening remote server Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.Server.html#get_file_append/4","title":"SscsEx.Server.get_file_append/4","type":"function","doc":"Resume the download of a remote file. Inputs: local_file: path of the local file, remote_file: path of the remote file, host: host name of remote server, port: port number of listening remote server Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.Server.html#handle_continue/2","title":"SscsEx.Server.handle_continue/2","type":"function","doc":"Invoked to handle continue instructions. It is useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way. Return values are the same as c:handle_cast/2. This callback is optional. If one is not implemented, the server will fail if a continue instruction is used. This callback is only supported on Erlang/OTP 21+. Callback implementation for GenServer.handle_continue/2."},{"ref":"SscsEx.Server.html#init/1","title":"SscsEx.Server.init/1","type":"function","doc":"Initialize the SSCS server: Inputs: _ options: SSH options Outputs: {:ok, state} | {:error, reason}"},{"ref":"SscsEx.Server.html#ping/2","title":"SscsEx.Server.ping/2","type":"function","doc":"Ping a remote server: Inputs: host: nale of remote host, port: port of remote host. Outputs: {:ok, &quot;SSH Host host, port is reachable&quot;} | {:error, &quot;SSH Host host, port is unreachable&quot; }"},{"ref":"SscsEx.Server.html#send_file/4","title":"SscsEx.Server.send_file/4","type":"function","doc":"Upload of a local file. Inputs: local_file: path of the local file, remote_file: path of the remote file, host: host name of remote server, port: port number of listening remote server Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.Server.html#send_file_append/4","title":"SscsEx.Server.send_file_append/4","type":"function","doc":"Resume the upload of a local file. Inputs: local_file: path of the local file, remote_file: path of the remote file, host: host name of remote server, port: port number of listening remote server Outputs: {:ok, message} | {:error, reason}"},{"ref":"SscsEx.Server.html#start_link/1","title":"SscsEx.Server.start_link/1","type":"function","doc":""},{"ref":"SscsEx.Server.html#terminate/2","title":"SscsEx.Server.terminate/2","type":"function","doc":"(Gracefully) Terminate the SSCS server: Save the failed transfers database to disk, Stop the SSH daemon."},{"ref":"SscsEx.StreamFile.html","title":"SscsEx.StreamFile","type":"module","doc":"A stream to download/upload file parts from a server through SFTP"},{"ref":"SscsEx.StreamFile.html#t:t/0","title":"SscsEx.StreamFile.t/0","type":"type","doc":""},{"ref":"SscsEx.Supervisor.html","title":"SscsEx.Supervisor","type":"module","doc":""},{"ref":"SscsEx.Supervisor.html#child_spec/1","title":"SscsEx.Supervisor.child_spec/1","type":"function","doc":"Returns a specification to start this module under a supervisor. See Supervisor."},{"ref":"SscsEx.Supervisor.html#init/1","title":"SscsEx.Supervisor.init/1","type":"function","doc":"Callback invoked to start the supervisor and during hot code upgrades. Developers typically invoke Supervisor.init/2 at the end of their init callback to return the proper supervision flags. Callback implementation for Supervisor.init/1."},{"ref":"SscsEx.Supervisor.html#start_link/0","title":"SscsEx.Supervisor.start_link/0","type":"function","doc":""},{"ref":"SscsEx.TransferDb.html","title":"SscsEx.TransferDb","type":"module","doc":"SscsEx.TransferDb: Manage the ETS/DETS database where the transfers are recorded and the failed ones, kept. When the SSCS server inits, DETS (ie on disk) table is copied to the ETS (ie in memory) table. If there&#39;s some failed transfers remaining, they are then retryed. All operation are then done on the ETS table and when (or if) the server terminate, the ETS table is saved back to the DETS table."},{"ref":"SscsEx.TransferDb.html#add/6","title":"SscsEx.TransferDb.add/6","type":"function","doc":"Add a transfer to ETS Table. Inputs: table: name of the ETS table, id: transfer Id, function: transfer function, local_path: path of local file, remote_path: path of remote file, host: name of remote server, port: port of remote server Outputs: {:ok, nil} | {:error, message}"},{"ref":"SscsEx.TransferDb.html#clean/1","title":"SscsEx.TransferDb.clean/1","type":"function","doc":"Remove all transfers from the ETS table. Inputs: table: ets table, Outputs: {:ok, nil} | {:error, &quot;No transfer table available.&quot;}"},{"ref":"SscsEx.TransferDb.html#dets_to_ets/1","title":"SscsEx.TransferDb.dets_to_ets/1","type":"function","doc":"Copy DETS file content to ETS Table. Inputs: file_name: name of the DETS file. Outputs: {:ok, ets table} | {:error, message}"},{"ref":"SscsEx.TransferDb.html#display/1","title":"SscsEx.TransferDb.display/1","type":"function","doc":"Display the ETS table content on standard output. Inputs: table: ets table, Outputs: {:ok, &quot;Failed transfers table content: transfer 1 , ... , transfer n&quot; } | {:error, &quot;No transfer table available.&quot;}"},{"ref":"SscsEx.TransferDb.html#elem_to_list/1","title":"SscsEx.TransferDb.elem_to_list/1","type":"function","doc":""},{"ref":"SscsEx.TransferDb.html#ets_to_dets/2","title":"SscsEx.TransferDb.ets_to_dets/2","type":"function","doc":"Copy ETS table content to DETS file. Inputs: ets: ets table, file_name: name of the DETS file. Outputs: {:ok, nil} | {:error, message}"},{"ref":"SscsEx.TransferDb.html#find/2","title":"SscsEx.TransferDb.find/2","type":"function","doc":"find a transfer in the ETS table. Inputs: table: ets table, id: transfer Id. Outputs: {:ok, record} | {:error, message}"},{"ref":"SscsEx.TransferDb.html#remove/2","title":"SscsEx.TransferDb.remove/2","type":"function","doc":"Remove a transfer from the ETS table. Inputs: table: ets table, id: transfer Id. Outputs: {:ok, nil} | {:error, message}"},{"ref":"SscsEx.TransferDb.html#tab2list/1","title":"SscsEx.TransferDb.tab2list/1","type":"function","doc":"Get the ETS table content and return it in a list. Inputs: table: ets table, Outputs: {:ok, [object 1, ... , object n]} | {:error, &quot;No transfer table available.&quot;}"},{"ref":"SscsEx.TransferDb.html#t:t/0","title":"SscsEx.TransferDb.t/0","type":"type","doc":""},{"ref":"SscsEx.Utils.html","title":"SscsEx.Utils","type":"module","doc":""},{"ref":"SscsEx.Utils.html#are_options/2","title":"SscsEx.Utils.are_options/2","type":"function","doc":"Test if every keys of required_keys are present in the keyword list options. ## Input: options: keyword list to test, required_keys: list of keys to test. Outputs: {:ok, nil} | {:error, message}"},{"ref":"SscsEx.Utils.html#force_tuple_result/1","title":"SscsEx.Utils.force_tuple_result/1","type":"function","doc":"Force the :ok/:error functions to return a tuple. Inputs: item: :ok, :error or any. Outputs: {:ok, nil} | {:error, nil} | any"},{"ref":"SscsEx.Utils.html#get_charlist/1","title":"SscsEx.Utils.get_charlist/1","type":"function","doc":"Force a String to be converted to a charlist (to feed the Erlang functions). Input: str: String or charlist. Outputs: char list"},{"ref":"SscsEx.Utils.html#is_port/1","title":"SscsEx.Utils.is_port/1","type":"function","doc":"Test if num is a valid port number. Input: num: an integer. Outputs: :ok | :error"},{"ref":"SscsEx.Utils.html#log_suppress/1","title":"SscsEx.Utils.log_suppress/1","type":"function","doc":"Disable logging while the function &#39;fun&#39; is executed. Input: fun: a function. Outputs: The output of the function"},{"ref":"SscsEx.Utils.html#stream_checksum/2","title":"SscsEx.Utils.stream_checksum/2","type":"function","doc":"Return the checksum of a stream. Input: stream: the stream, crc_type: type of checksum. can be: :sha, :sha224, :sha256, :sha384, :sha512, :sha3_224, :sha3_256, :sha3_384, :sha3_512, :blake2b, :blake2s, :md5 or :md4 Outputs: checksum"},{"ref":"SscsEx.Utils.html#transfer_rate/3","title":"SscsEx.Utils.transfer_rate/3","type":"function","doc":"Compute a transfer rate. ## Input: file_size: the size of the file, seconds: the time elapsed in seconds, unit: the unit: can be: :mb (MB) or :kb (KB). Outputs: {:ok, transfer rate} | {:error, message}"},{"ref":"SscsEx.Utils.html#tuple_to_response/2","title":"SscsEx.Utils.tuple_to_response/2","type":"function","doc":"Return the second part of a response tuple ({:ok, item} or {:error, item}) when :ok. default otherwise. (Usefull for piping !) Inputs: {ok_or_error, item }: {:ok, item} | {:error, item} default: default value when ok_or_error is not :ok Outputs: item or default"},{"ref":"readme.html","title":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)...","type":"extras","doc":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)..."},{"ref":"readme.html#prior-and-very-important-notice","title":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)... - PRIOR AND VERY IMPORTANT NOTICE !!!:","type":"extras","doc":"THIS is NOT a 100% bug free: So USE IT at your OWN RISKS with NO GARANTEE AT ALL ! THIS will probably NEVER BE UPDATED: Just intended to give some pieces of help to those who are exploring the same matters (SSH/SFTP exchanges) in Elixir, ENGLISH IS NOT MY NATIVE LANGUAGE: Beeing French is a very good excuse as the time spent to learn such a difficult/full of exceptions/full of oddities language as mine is lost to correctly learn others... Especially for an old and lazy bloke as me ! ;) Now that&#39;s done, let&#39;s go ! SscsEx is a basic sftp server with a client part added to allow files transfers between two SSCS servers. Authentification for connection from a SSCS server to another SSCS server uses public keys only. The transfers are always processed by streaming files (chunk by chunk). To avoid integrity problems, checksums of source and destination files are computed and compared for each transfer. When a transfer fails, resume can happen. If a SSCS server is (normally) stopped, the failed transfers are saved on a disk database (DETS) and when the server restart, these transfers are then resumed. If some part of the destination file is already present and its size is less than the source file size, the difference is appended to the destination file, whatever could the OVERWRITE option (see below) be. The Elixir files of this project can be compiled as an Elixir &quot;release&quot; to make a bundle which can be copied and directly launched on a computer with the same OS, even if Elixir or Erlang are not installed on it. More informations about releases on the official documentation page"},{"ref":"readme.html#particularities","title":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)... - Particularities :","type":"extras","doc":"Elixir tasks are initiated by the GenServer.cast functions to avoid the wait for a transfer to complete before another one is launched (asynchronous transfers). Returns are received by the handle_info functions. A file, named sscs_tranfers.db (DETS file), containing the failed transfers datas, is created or read when the SSCS server is launched. This file is located in the root folder of the application. The HTML documentation, generated by ExDoc, is available in the doc folder. The @specs (giving the type of each argument) are not set, except for the SscsEx.SFTP module. No other library than the standard Erlang :ssh and :ssh_sftp libraries has been used as dependencies for the SSH/SFTP part."},{"ref":"readme.html#dependencies-when-mix_env-prod","title":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)... - Dependencies (when MIX_ENV = prod):","type":"extras","doc":"Only: Elixir_uuid: To generate unique Ids for transfers, Logger File Backend: To enable logging in the console and in a file."},{"ref":"readme.html#system-variables","title":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)... - System variables :","type":"extras","doc":"The following variables: SSCS_PORT (Integer : 0-65536) = listening port of the SSCS server (default = 5555), SSCS_LOG_FILE (String) = complete path to the log file (default = subfolder/file &quot;/log/sscs.log&quot; of the release), SSCS_ROOT_DIR (String) : root folder to send or receive files (default = subfolder &quot;/sftp&quot; of the release), SSCS_AUTH_DIR (String) : folder containing the authorized keys (default = subfolder &quot;/sftp/.ssh&quot; of the release), SSCS_SYSTEM_DIR (String) : folder containing the server SSH keys (default = subfolder &quot;/sftp/ssh_daemon&quot; of the release), SSCS_STREAM_BYTES (Integer): Size of chunks streamed, in bytes (default = 2 Mo), SSCS_CHECKSUM_TYPE (String : &quot;sha&quot;, &quot;sha224&quot; &quot;sha256&quot;,&quot;sha384&quot;,&quot;sha512&quot;,&quot;sha3_224&quot;, &quot;sha3_256&quot;,&quot;sha3_384&quot;,&quot;sha3_512&quot;, &quot;blake2b&quot;, &quot;blake2s&quot;, &quot;md5&quot;, &quot;md4&quot;): checksum type used (default = &quot;sha256&quot;). SSCS_OVERWRITE (String: &quot;true&quot; or &quot;false&quot;): Enable or disable overwriting destination files if they exist. No retry attempted if with SSCS_OVERWRITE set to false (default = &quot;false&quot;), SSCS_RETRIES (Integer): max retries to a failed transfer (default = 3), SSCS_TEMP_RETRY (Integer): time, in milli-seconds, between two retry attempts (default = 180000, 3 minutes). can be set before launching the SSCS server. The SSCS server will log simultaneously in the SSCS_LOG_FILE and in the console. Examples : 14:39:09.708 [info] SUCCESS: Transfer_id = &quot;8ac1d2c6-bfcc-4412-867f-3d771ead3ecb&quot; : Local file = c:/SSCS/sftp/success.txt sent to : Remote file = tr/success.txt : Remote server = &#39;mydistantSSCSserver&#39;:5555 : Average transfer rate = 0.0 Mb/s : Checksum (type: sha256 ) for both files = C784C2AF93C512DA33C363A2E3D8CEAFE45D3A80B88B762CE015914B00D496AD or (with SSCS_OVERWRITE set to &quot;false&quot;): 10:51:48.459 [error] FAILURE : Transfer_id = &quot;8e0eb430-42d5-49ce-b472-4ccfd876c476&quot; : Local file = c:/SSCS/sftp/failure.txt WAS NOT sent to : Remote file = tr/failure.txt: Remote server = &#39;localhost&#39;:5000} : &quot;Upload error: Remote file tr/failure.txt already exists.&quot; NO RETRY permitted ! or: 10:54:48.528 [error] FAILURE (Retry 1): Transfer_id = &quot;8e0eb430-42d5-4412-867f-3d771ead3ecb&quot; : Local file = c:/SSCS/sftp/resume.txt WAS NOT sent to : Remote file = tr/resume.txt : Remote server = &#39;localhost&#39;:5000} : &quot;Connection error - Reason: :econnrefused&quot; Retrying later... 10:57:48.559 [error] FAILURE (Retry 2): Transfer_id = &quot;8e0eb430-42d5-4412-867f-3d771ead3ecb&quot; : Local file = c:/SSCS/sftp/resume.txt WAS NOT sent to : Remote file = tr/resume.txt : Remote server = &#39;localhost&#39;:5000} : &quot;Connection error - Reason: :econnrefused&quot; Retrying later... 11:00:48.590 [info] : Transfer_id = &quot;8e0eb430-42d5-49ce-b472-4ccfd876c476&quot; : Local file = c:/SSCS/sftp/resume.txt was sent to : Remote file = tr/resume.txt : Remote server = &#39;localhost&#39;:5000} : Average transfer rate = 0.0 Mb/s : Checksum (type: sha256 ) for both files = 3EEE6DBF789756FAF9C9BCE07FEB38FEAF221E83E4FA83D61D39A6B63D47F335"},{"ref":"readme.html#sscs-available-functions","title":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)... - SSCS available functions :","type":"extras","doc":"SscsEx.start(&quot;&quot;,&quot;&quot;) : Start the server. SscsEx.stop() : Stop the server. SscsEx.get_conf() : Display the current configuration (SSH, transferts, logging) of the application, as an array. SscsEx.display_failed_transfers() : Display the failed transfers list. SscsEx.clean_failed_transfers() : Empty the failed transfers list. SscsEx.ping(&#39;&lt;host_name&gt;&#39;,&lt;port&gt;) : Check if a SSCS server is reachable. SscsEx.send_file(local_path, remote_path, host, port): Send/Upload a file. SscsEx.get_file(local_path, remote_path, host, port): Get/Download a file. SscsEx.send_file_append(local_path, remote_path, host, port) : Append the exceeding part of local file to the remote file, with checksum checks (WARNING !: No verification done a priori to ensure that the remote file is the first part of the local file !!!). SscsEx.get_file_append(local_path, remote_path, host, port) : Append the exceeding part of remote file to the local file, with checksum checks (WARNING !: No verification done a priori to ensure that the local file is the first part of the remote file !!!). with: local_path(String surrounded by &#39; or &quot;, ) = complete path of the local file, relative to the SSCS_ROOT_DIR, remote_path (String surrounded by &#39; or &quot;, ) = complete path of the remote file, relative to the SSCS_ROOT_DIR, host (String surrounded by &#39; or &quot;, ) = name of remote server (IP address or DNS name), port (integer: 0 to 65535) = listening port of SSCS remote server."},{"ref":"readme.html#sscs-server-launch-using-a-release","title":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)... - SSCS server launch (using a release) :","type":"extras","doc":"&lt;release folder&gt;\\bin\\SSCS_ex start (*) The console should display: [info] SSCS server started on port 5555..."},{"ref":"readme.html#transfers-launches-console-or-script","title":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)... - Transfers launches (console or script)","type":"extras","doc":"Open another console then type : &lt;release folder&gt;\\bin\\SSCS_ex rpc &quot;&lt;function&gt;(&lt;arguments&gt;)&quot; example: SSCS_ex rpc &quot;SscsEx.send_file(&#39;mysourcefile.ext&#39;, &#39;mydestinationfile.ext&#39;, &#39;myremotehost&#39;, 5555)&quot;"},{"ref":"readme.html#properly-stop-the-sscs-server","title":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)... - (Properly) stop the SSCS server","type":"extras","doc":"&lt;release folder&gt;\\bin\\SSCS_ex stop (*) (*): To see all the availables options depending on the OS, go to the official documentation page of Mix Release On Windows, commands are: start: Start the SSCS server, start_iex: Start the SSCS server in an IEx console (Elixir interpreter), install: Install the SSCS server as a Windows service, rpc &quot;FUNC&quot;: Executes the &quot;FUNC&quot; function, restart: Restart the SSCS server, stop: Stop the SSCS server, pid: Display the SSCS server PID, version: Display the SSCS server version."},{"ref":"readme.html#credits","title":"SscsEx : (An attempt to) create a Simple SFTP Client/Serveur (SSCS) written in Elixir (Ex)... - Credits :","type":"extras","doc":"Great thanks to: Michael Dorman for his Sftp_Ex library, Codenaut for his Exsftpd library, Tobias Casper for his SFTP Client library, All the people who kindly gave me help on the Elixir Forum."}]